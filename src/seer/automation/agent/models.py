import dataclasses
from enum import Enum
from typing import Generic, Optional, TypeVar

from pydantic import BaseModel


class ToolCall(BaseModel):
    id: Optional[str] = None
    function: str
    args: str


class Usage(BaseModel):
    completion_tokens: int = 0
    prompt_tokens: int = 0
    total_tokens: int = 0
    prompt_cache_write_tokens: int = 0
    prompt_cache_read_tokens: int = 0

    def __add__(self, other: "Usage"):
        return Usage(
            completion_tokens=self.completion_tokens + other.completion_tokens,
            prompt_tokens=self.prompt_tokens + other.prompt_tokens,
            total_tokens=self.total_tokens + other.total_tokens,
        )

    def __sub__(self, other: "Usage"):
        return Usage(
            completion_tokens=self.completion_tokens - other.completion_tokens,
            prompt_tokens=self.prompt_tokens - other.prompt_tokens,
            total_tokens=self.total_tokens - other.total_tokens,
        )

    def to_langfuse_usage(self):
        return {
            "prompt_tokens": self.prompt_tokens
            + self.prompt_cache_write_tokens
            + self.prompt_cache_read_tokens,
            "completion_tokens": self.completion_tokens,
            "total_tokens": self.total_tokens,
        }


class LlmProviderType(str, Enum):
    OPENAI = "openai"
    ANTHROPIC = "anthropic"
    GEMINI = "gemini"


class Message(BaseModel):
    content: Optional[str] = None
    """The text of the message."""

    role: str = "user"
    """The role of the author of this message."""

    thinking_content: Optional[str] = None
    """The thinking content of the message (for reasoning models)."""

    thinking_signature: Optional[str] = None
    """The signature of the thinking block (for reasoning models)."""

    tool_calls: Optional[list[ToolCall]] = None
    """The tool calls generated by the model, such as function calls."""

    tool_call_id: Optional[str] = None
    """The ID of the tool call."""

    tool_call_function: Optional[str] = None
    """The function of the tool call."""


class LlmResponseMetadata(BaseModel):
    model: str
    provider_name: LlmProviderType
    usage: Usage


class LlmGenerateTextResponse(BaseModel):
    message: Message
    metadata: LlmResponseMetadata


StructuredOutputType = TypeVar("StructuredOutputType")


@dataclasses.dataclass
class LlmGenerateStructuredResponse(Generic[StructuredOutputType]):
    parsed: StructuredOutputType
    metadata: LlmResponseMetadata


class LlmProviderDefaults(BaseModel):
    temperature: float | None = None


class LlmModelDefaultConfig(BaseModel):
    match: str
    defaults: LlmProviderDefaults


class LlmRefusalError(Exception):
    """Raised when the LLM refuses to complete the request."""

    pass


class LlmStreamTimeoutError(TimeoutError):
    """Raised when the LLM stream times out."""

    pass


class LlmStreamFirstTokenTimeoutError(LlmStreamTimeoutError):
    """Raised when the LLM takes too long to generate the first token."""

    pass


class LlmStreamInactivityTimeoutError(LlmStreamTimeoutError):
    """Raised when the LLM stream times out due to inactivity."""

    pass
