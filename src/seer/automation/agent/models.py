import json
from enum import Enum
from typing import Any, Optional

from pydantic import BaseModel


class ToolCall(BaseModel):
    id: Optional[str] = None
    function: str
    args: str


class Usage(BaseModel):
    completion_tokens: int = 0
    prompt_tokens: int = 0
    total_tokens: int = 0

    def __add__(self, other: "Usage"):
        return Usage(
            completion_tokens=self.completion_tokens + other.completion_tokens,
            prompt_tokens=self.prompt_tokens + other.prompt_tokens,
            total_tokens=self.total_tokens + other.total_tokens,
        )

    def __sub__(self, other: "Usage"):
        return Usage(
            completion_tokens=self.completion_tokens - other.completion_tokens,
            prompt_tokens=self.prompt_tokens - other.prompt_tokens,
            total_tokens=self.total_tokens - other.total_tokens,
        )


class LlmProviderType(str, Enum):
    OPENAI = "openai"
    ANTHROPIC = "anthropic"


class Message(BaseModel):
    content: Optional[str] = None
    """The text of the message."""

    role: str = "user"
    """The role of the author of this message."""

    tool_calls: Optional[list[ToolCall]] = None
    """The tool calls generated by the model, such as function calls."""

    tool_call_id: Optional[str] = None

    def to_message(self, provider_name: LlmProviderType) -> dict[str, Any]:
        if provider_name == LlmProviderType.OPENAI:
            message: dict[str, Any] = dict(
                content=self.content if self.content else "", role=self.role
            )

            if self.tool_calls:
                tool_calls = [tool_call.model_dump(mode="json") for tool_call in self.tool_calls]
                parsed_tool_calls = []
                for item in tool_calls:
                    new_item = item.copy()
                    new_item["function"] = {"name": item["function"], "arguments": item["args"]}
                    new_item["type"] = "function"
                    parsed_tool_calls.append(new_item)
                message["tool_calls"] = parsed_tool_calls

            if self.tool_call_id:
                message["tool_call_id"] = self.tool_call_id

            return message

        elif provider_name == LlmProviderType.ANTHROPIC:
            if self.role == "tool":
                return {
                    "role": "user",
                    "content": [
                        {
                            "type": "tool_result",
                            "content": self.content,
                            "tool_use_id": self.tool_call_id,
                        }
                    ],
                }
            elif self.role == "tool_use":
                if not self.tool_calls:
                    return {}
                tool_call = self.tool_calls[0]  # Assuming only one tool call per message
                return {
                    "role": "assistant",
                    "content": [
                        {
                            "type": "tool_use",
                            "id": tool_call.id,
                            "name": tool_call.function,
                            "input": json.loads(tool_call.args),
                        }
                    ],
                }
            else:
                return {
                    "role": self.role,
                    "content": [{"type": "text", "text": self.content}],
                }
        else:
            raise ValueError(f"Unsupported provider: {provider_name}")
